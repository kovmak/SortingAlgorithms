# Sorting Algorithms Implementation

## Practical Work #3: Sorting Algorithms

### Introduction
This repository contains the step-by-step implementation and visualization of various sorting algorithms applied to arrays of natural numbers. The following sorting algorithms are demonstrated:

1. **Bubble Sort**
2. **Insertion Sort**
3. **Selection Sort**
4. **Merge Sort**
5. **Quicksort**

### Tasks
1. **Algorithm Demonstration:**
   - Apply each sorting algorithm to the provided array of natural numbers.
   - Illustrate the step-by-step process for better understanding.

2. **Block Diagrams:**
   - Create block diagrams for each sorting algorithm to visualize their workflow.

### Implementation Requirements
1. **Bubble Sort:**
   - Iterate through the array, swapping adjacent elements if they are in the wrong order.
   - Repeat the process until the array is sorted.

2. **Insertion Sort:**
   - Build the sorted array one element at a time by repeatedly taking elements from the unsorted part and inserting them into their correct position in the sorted part.

3. **Selection Sort:**
   - Divide the array into a sorted and an unsorted region.
   - Select the smallest element from the unsorted region and swap it with the first element of the unsorted region.
   - Expand the sorted region and repeat until the entire array is sorted.

4. **Merge Sort:**
   - Recursively divide the array into two halves.
   - Merge the sorted halves to produce a single sorted array.

5. **Quicksort:**
   - Choose a pivot element from the array.
   - Partition the other elements into two sub-arrays according to whether they are less than or greater than the pivot.
   - Recursively sort the sub-arrays.

### How to Use
1. Clone the repository to your local machine.
2. Open the provided implementation files for each sorting algorithm using your preferred programming language.
3. Execute the program, observing the step-by-step sorting process.

### Block Diagrams
Find the block diagrams for each sorting algorithm in the "diagrams" directory.

### Evaluation and Conclusion
Evaluate the performance and efficiency of each sorting algorithm based on the provided array. Consider factors such as time complexity, number of operations, and ease of understanding. Contributions, issues, and improvements are welcome.
